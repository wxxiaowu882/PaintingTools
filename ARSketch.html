<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR ææ‘¹åŠ©æ‰‹ | è§†è§‰ç»´åº¦</title>
    
    <!-- 1. A-Frame 1.2.0 (ç¨³å®šç‰ˆ) -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- 2. AR.js for A-Frame -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #111; }
        .a-enter-vr { display: none; }

        /* === å±å¹•é™æ€å±‚ === */
        #screen-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: auto; overflow: hidden;
            display: none; cursor: grab;
        }
        /* æ ¡å‡†æ—¶æ˜¾ç¤ºåŠé€æ˜å‚è€ƒå›¾ */
        #screen-layer.calibrating { pointer-events: none; opacity: 0.4; } 
        #screen-layer:active { cursor: grabbing; }
        
        #screen-img {
            position: absolute;
            top: 50%; left: 50%;
            /* å…³é”®ï¼šé™åˆ¶æœ€å¤§å°ºå¯¸ï¼Œé˜²æ­¢å›¾ç‰‡è¿‡å¤§æº¢å‡º */
            max-width: 80%; 
            max-height: 80%;
            /* ç§»é™¤å›ºå®š widthï¼Œè®© max-width ç”Ÿæ•ˆï¼Œä¿æŒæ¯”ä¾‹ */
            pointer-events: none; 
            /* ä¿®æ”¹å›ï¼šé”šç‚¹è®¾ä¸ºä¸­å¿ƒ */
            transform-origin: center center;
            /* æ¢å¤é»˜è®¤å±…ä¸­ translate */
            transform: translate(-50%, -50%); 
            /* ç§»é™¤ transition ä»¥ä¿è¯å®æ—¶æ‹–æ‹½è·Ÿæ‰‹ */
        }

        /* === UI æ§åˆ¶å±‚ === */
        .ui-layer {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 400px;
            background: rgba(28, 28, 30, 0.9); backdrop-filter: blur(10px);
            border-radius: 20px; padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; gap: 15px;
            color: white; z-index: 100;
        }

        /* æ”¶èµ·æŒ‰é’®æ ·å¼ */
        .btn-minimize {
            position: absolute; top: 10px; right: 10px;
            width: 30px; height: 30px; padding: 0;
            background: rgba(255,255,255,0.1); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; border: none; cursor: pointer; color: #ccc;
        }
        
        /* æ¢å¤æŒ‰é’®æ ·å¼ */
        #restore-btn {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 48px; height: 48px; border-radius: 24px;
            background: rgba(28, 28, 30, 0.9); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            color: white; font-size: 20px; 
            display: none; /* é»˜è®¤éšè— */
            align-items: center; justify-content: center;
            z-index: 99; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .top-bar {
            position: fixed; top: 0; left: 0; width: 100%; height: 60px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 100; display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; box-sizing: border-box; color: white;
            pointer-events: none; 
        }
        .top-bar > * { pointer-events: auto; }

        .status-badge {
            background: rgba(255,255,255,0.2); padding: 5px 12px;
            border-radius: 15px; font-size: 12px; font-weight: 600;
            display: flex; align-items: center; gap: 5px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #aaa; }
        .status-dot.active { background: #4CD964; box-shadow: 0 0 8px #4CD964; }
        .status-dot.calib { background: #FFD60A; box-shadow: 0 0 8px #FFD60A; animation: pulse 1s infinite; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .label { font-size: 14px; min-width: 40px; color: #ccc; }
        input[type=range] { flex: 1; accent-color: #007AFF; height: 4px; border-radius: 2px; }
        
        button {
            flex: 1; padding: 12px; border-radius: 12px; border: none;
            background: rgba(255,255,255,0.15); color: white;
            font-size: 14px; font-weight: 600; cursor: pointer; transition: 0.2s;
        }
        button.active { background: #007AFF; color: white; }
        
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center;
        }
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="margin-bottom: 10px;">ğŸ¨ AR ææ‘¹åŠ©æ‰‹</h1>
        <p style="opacity: 0.6; margin-bottom: 40px; font-size: 14px;">åŒæ¨¡å¼•æ“ï¼šå±å¹•å›ºå®š + AR ç©ºé—´è·Ÿéš</p>
        <div style="display: flex; flex-direction: column; gap: 15px; width: 200px;">
            <button onclick="document.getElementById('file-input').click()" style="background: #333; border: 1px solid #555;">
                1. é€‰æ‹©å›¾ç‰‡
            </button>
            <button id="btn-start-cam" onclick="startApp()" class="active" style="display: none;">
                2. å¯åŠ¨æ‘„åƒå¤´
            </button>
        </div>
        <input type="file" id="file-input" accept="image/*">
        <p id="file-name" style="margin-top: 20px; font-size: 12px; color: #007AFF;"></p>
    </div>

    <!-- AR åœºæ™¯ -->
    <a-scene 
        id="ar-scene"
        embedded 
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono; maxDetectionRate: 60;"
        renderer="logarithmicDepthBuffer: true;"
        vr-mode-ui="enabled: false">

        <!-- smoothCount=10 å¢åŠ å¹³æ»‘åº¦ -->
        <a-marker preset="hiro" id="ar-marker" emitevents="true" smooth="true" smoothCount="10" smoothTolerance="0.01">
            <!-- åˆå§‹ visible=falseï¼Œæ ¡å‡†å®Œæˆåæ˜¾ç¤º -->
            <a-image 
                id="ar-img" 
                src="" 
                position="0 0 0" 
                rotation="-90 0 0" 
                scale="1 1 1"
                opacity="0.5"
                visible="false">
            </a-image>
        </a-marker>
        <a-entity camera></a-entity>
    </a-scene>

    <div id="screen-layer">
        <img id="screen-img" src="" alt="Overlay">
    </div>

    <div class="top-bar">
        <div class="status-badge">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">æ‰‹åŠ¨æ¨¡å¼</span>
        </div>
        <button style="width: auto; padding: 5px 15px; font-size: 12px;" onclick="toggleLock()" id="btn-lock">ğŸ”“</button>
    </div>

    <!-- æ¢å¤æŒ‰é’® (åˆå§‹éšè—) -->
    <button id="restore-btn" onclick="toggleUI(true)">ğŸ› ï¸</button>

    <div class="ui-layer" id="controls" style="display: none;">
        <!-- æœ€å°åŒ–æŒ‰é’® -->
        <button class="btn-minimize" onclick="toggleUI(false)">ğŸ”½</button>

        <div class="row">
            <span class="label">é€æ˜</span>
            <input type="range" id="opacity" min="0" max="1" step="0.05" value="0.5" oninput="updateVisuals()">
        </div>
        <div class="row">
            <span class="label">å¤§å°</span>
            <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1" oninput="updateVisuals()">
        </div>
        <div class="row">
            <span class="label">æ—‹è½¬</span>
            <input type="range" id="rotate" min="0" max="360" step="1" value="0" oninput="updateVisuals()">
        </div>
        
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="btn-mode" onclick="toggleMode()">ğŸ“ å¯ç”¨è·Ÿéš</button>
            <button onclick="resetParams()">é‡ç½®</button>
        </div>
        <p style="margin: 0; font-size: 10px; opacity: 0.4; text-align: center;">è·Ÿéšæ¨¡å¼éœ€å¯¹å‡† Hiro æ ‡è®°</p>
    </div>

    <script>
        const state = {
            imageLoaded: false,
            cameraStarted: false,
            arMode: false,
            markerFound: false,
            locked: false,
            // å˜æ¢å‚æ•°
            opacity: 0.5,
            scale: 1, 
            rotate: 0,
            // å±å¹•åç§»
            screenX: 0,
            screenY: 0,
            // AR å°ºå¯¸æ ¡å‡†
            arScaleMult: null,
            arBaseWidth: 1,
            arWidth: 1,  // AR å›¾ç‰‡åŸå§‹å®½
            arHeight: 1, // AR å›¾ç‰‡åŸå§‹é«˜
            // ç¼“å­˜çš„å±å¹•å›¾ç‰‡åŸå§‹å®½åº¦ï¼ˆä¸å«ç¼©æ”¾ï¼‰
            cachedClientWidth: 0,
            // æ ¡å‡†è®¡æ•°å™¨
            calibFrameCount: 0
        };

        const els = {
            startScreen: document.getElementById('start-screen'),
            fileInput: document.getElementById('file-input'),
            btnStartCam: document.getElementById('btn-start-cam'),
            fileName: document.getElementById('file-name'),
            screenLayer: document.getElementById('screen-layer'), 
            screenImg: document.getElementById('screen-img'),
            arImg: document.getElementById('ar-img'),
            controls: document.getElementById('controls'),
            statusText: document.getElementById('status-text'),
            statusDot: document.getElementById('status-dot'),
            marker: document.getElementById('ar-marker'),
            btnMode: document.getElementById('btn-mode'),
            restoreBtn: document.getElementById('restore-btn'), // æ–°å¢
            scene: document.querySelector('a-scene'),
            inputs: {
                opacity: document.getElementById('opacity'),
                scale: document.getElementById('scale'),
                rotate: document.getElementById('rotate')
            }
        };

        // UI åˆ‡æ¢åŠŸèƒ½
        function toggleUI(show) {
            if (show) {
                els.controls.style.display = 'flex';
                els.restoreBtn.style.display = 'none';
            } else {
                els.controls.style.display = 'none';
                els.restoreBtn.style.display = 'flex';
            }
        }

        // 1. ä¸Šä¼ 
        els.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const src = event.target.result;
                els.screenImg.src = src;
                els.screenImg.style.display = 'block'; 
                els.arImg.setAttribute('src', src);

                // è®¡ç®—åŸºç¡€æ¯”ä¾‹
                const tempImg = new Image();
                tempImg.onload = () => {
                    const ratio = tempImg.naturalWidth / tempImg.naturalHeight;
                    // ä¿å­˜æ¯”ä¾‹ä¾›æ ¡å‡†ä½¿ç”¨
                    if (ratio > 1) {
                        state.arBaseWidth = 1;
                        state.arWidth = 1;
                        state.arHeight = 1 / ratio;
                    } else {
                        state.arBaseWidth = ratio;
                        state.arWidth = ratio;
                        state.arHeight = 1;
                    }
                    els.arImg.setAttribute('width', state.arWidth);
                    els.arImg.setAttribute('height', state.arHeight);
                };
                tempImg.src = src;

                state.imageLoaded = true;
                els.fileName.innerText = `âœ… å·²é€‰: ${file.name}`;
                els.btnStartCam.style.display = 'block'; 
            };
            reader.readAsDataURL(file);
        });

        // 2. å¯åŠ¨
        function startApp() {
            if (!state.imageLoaded) return;
            els.startScreen.style.display = 'none';
            els.screenLayer.style.display = 'block'; 
            els.screenImg.style.display = 'block'; // ç¡®ä¿æ˜¾ç¤º
            els.controls.style.display = 'flex';
            state.cameraStarted = true;
            
            // ä¼˜åŒ–ç‚¹1ï¼šå¯åŠ¨æ—¶é‡ç½®å±…ä¸­
            state.screenX = 0; 
            state.screenY = 0;
            updateVisuals();
        }

        // 3. æ¨¡å¼åˆ‡æ¢
        function toggleMode() {
            state.arMode = !state.arMode;
            
            if (state.arMode) {
                // è¿›å…¥ AR æ¨¡å¼
                
                // ä¼˜åŒ–ç‚¹2ï¼šè®°å½•å½“å‰å±å¹•å›¾ç‰‡çš„â€œåŸå§‹â€æ¸²æŸ“å®½åº¦ï¼ˆclientWidth ä¸åŒ…å« transform: scaleï¼‰
                // è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è®¡ç®—å‡ºâ€œä¸ç¼©æ”¾æ—¶çš„åŸºå‡†åƒç´ å®½åº¦â€ï¼Œç„¶ååœ¨ AR ä¸­åº”ç”¨åŒæ ·çš„ scale
                state.cachedClientWidth = els.screenImg.clientWidth;

                els.btnMode.classList.add('active');
                els.btnMode.innerText = "ğŸ“º åˆ‡å›å±å¹•";
                
                // é‡ç½®æ ¡å‡†
                state.arScaleMult = null;
                state.calibFrameCount = 0;
                
                // éšè— AR å›¾ï¼Œç­‰å¾…æ ¡å‡†
                els.arImg.setAttribute('visible', 'false');
                
                // ä¿æŒå±å¹•å›¾å¯è§ï¼Œç”¨äºè§†è§‰æ ¡å‡†è¿‡æ¸¡
                els.screenLayer.classList.add('calibrating');
                
                if (state.markerFound) {
                    startCalibration();
                } else {
                    els.statusText.innerText = "å¯»æ‰¾æ ‡è®°...";
                    els.statusDot.className = "status-dot";
                }
            } else {
                // åˆ‡å›æ‰‹åŠ¨
                els.btnMode.classList.remove('active');
                els.btnMode.innerText = "ğŸ“ å¯ç”¨è·Ÿéš";
                
                els.screenLayer.style.display = 'block'; 
                els.screenLayer.classList.remove('calibrating');
                els.screenImg.style.opacity = state.opacity;
                els.arImg.setAttribute('visible', 'false'); 
                
                els.statusText.innerText = "å±å¹•æ‰‹åŠ¨æ¨¡å¼";
                els.statusDot.className = "status-dot active";
            }
            updateVisuals();
        }

        // 4. è§†è§‰æ›´æ–°
        function updateVisuals() {
            state.opacity = els.inputs.opacity.value;
            state.scale = els.inputs.scale.value;
            state.rotate = els.inputs.rotate.value;

            // å±å¹•å›¾
            if (!els.screenLayer.classList.contains('calibrating')) {
                els.screenImg.style.opacity = state.opacity;
            }
            // ä¿®æ”¹å›ï¼šä½¿ç”¨ä¸­å¿ƒé”šç‚¹é€»è¾‘ï¼Œæ¢å¤ -50% å±…ä¸­åç§»
            els.screenImg.style.transform = 
                `translate(calc(-50% + ${state.screenX}px), calc(-50% + ${state.screenY}px)) ` + 
                `scale(${state.scale}) rotate(${state.rotate}deg)`;

            // AR å›¾
            // æ ¸å¿ƒï¼šåº”ç”¨æ ¡å‡†ç³»æ•° arScaleMult
            const finalARScale = state.scale * (state.arScaleMult || 1);
            
            els.arImg.setAttribute('opacity', state.opacity);
            els.arImg.object3D.rotation.set(
                THREE.Math.degToRad(-90), 
                THREE.Math.degToRad(state.rotate), 
                0
            );
            
            // ä¿®æ”¹å›ï¼šç§»é™¤åç§»ï¼Œä½¿ä¸­å¿ƒå¯¹é½ Marker ä¸­å¿ƒ
            els.arImg.object3D.position.set(0, 0, 0);
            els.arImg.object3D.scale.set(finalARScale, finalARScale, 1);
        }

        // --- æ ¸å¿ƒï¼šè¿ç»­åŠ¨æ€æ ¡å‡† ---
        function startCalibration() {
            els.statusText.innerText = "ğŸ“ æ ¡å‡†å¤§å°...";
            els.statusDot.className = "status-dot calib";
            els.screenLayer.classList.add('calibrating'); 
            requestAnimationFrame(calibrateLoop);
        }

        function calibrateLoop() {
            if (!state.arMode || !els.marker.object3D.visible) {
                els.screenLayer.classList.remove('calibrating');
                if (state.arMode) els.arImg.setAttribute('visible', 'false');
                return;
            }

            // æ ¡å‡† 30 å¸§ (çº¦0.5ç§’) ä»¥ç¨³å®šæ•°å€¼
            if (state.calibFrameCount < 30) {
                performCalibrationStep();
                state.calibFrameCount++;
                requestAnimationFrame(calibrateLoop);
            } else {
                finishCalibration();
            }
        }

        function performCalibrationStep() {
            const camera = els.scene.camera;
            const object3D = els.marker.object3D;
            
            // ä½¿ç”¨å·¦å³è¾¹ç¼˜ç‚¹ (-0.5 åˆ° 0.5) è®¡ç®— 1 ä¸ªå•ä½å®½åº¦åœ¨å±å¹•ä¸Šçš„æŠ•å½±é•¿åº¦
            // è¿™æ ·æ¯”ä¸­å¿ƒåˆ°è¾¹ç¼˜æ›´å‡†ï¼Œä¸”ç¬¦åˆ state.arBaseWidth çš„å®šä¹‰
            // å‡è®¾ AR å›¾ç‰‡çš„å±€éƒ¨ç©ºé—´å®½åº¦æ˜¯ state.arBaseWidth
            const halfW = state.arBaseWidth / 2;
            
            const pLeft = new THREE.Vector3(-halfW, 0, 0);
            pLeft.applyMatrix4(object3D.matrixWorld).project(camera);
            
            const pRight = new THREE.Vector3(halfW, 0, 0);
            pRight.applyMatrix4(object3D.matrixWorld).project(camera);
            
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            const x1 = (pLeft.x * 0.5 + 0.5) * w;
            const y1 = -(pLeft.y * 0.5 + 0.5) * h;
            const x2 = (pRight.x * 0.5 + 0.5) * w;
            const y2 = -(pRight.y * 0.5 + 0.5) * h;
            
            const distPx = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            
            if (distPx > 1) {
                // å…¬å¼æ¨å¯¼ï¼š
                // AR_Visual_Width_Px = distPx * FinalARScale
                // Screen_Visual_Width_Px = state.cachedClientWidth * state.scale
                // æˆ‘ä»¬å¸Œæœ›ï¼šAR_Visual_Width_Px == Screen_Visual_Width_Px
                // distPx * state.scale * arScaleMult = state.cachedClientWidth * state.scale
                // æ¶ˆå» state.scale:
                // arScaleMult = state.cachedClientWidth / distPx
                
                const calculatedMult = state.cachedClientWidth / distPx;
                
                if (calculatedMult > 0 && calculatedMult < 1000) {
                    if (state.arScaleMult === null) {
                        state.arScaleMult = calculatedMult;
                    } else {
                        // å¹³æ»‘é€¼è¿‘
                        state.arScaleMult += (calculatedMult - state.arScaleMult) * 0.2;
                    }
                    
                    updateVisuals(); 
                    els.arImg.setAttribute('visible', 'true');
                }
            }
        }

        function finishCalibration() {
            els.statusText.innerText = "âœ… è·Ÿéšä¸­ (å·²é”å®š)";
            els.statusDot.className = "status-dot active";
            els.screenLayer.classList.remove('calibrating');
            els.screenLayer.style.display = 'none'; // éšè—å‚è€ƒå›¾
        }

        // --- AR äº‹ä»¶ ---
        els.marker.addEventListener('markerFound', () => {
            state.markerFound = true;
            if (state.arMode) {
                if (state.arScaleMult === null) {
                    startCalibration();
                } else {
                    els.statusText.innerText = "AR è·Ÿéšä¸­";
                    els.statusDot.className = "status-dot active";
                    els.arImg.setAttribute('visible', 'true');
                }
            }
        });

        els.marker.addEventListener('markerLost', () => {
            state.markerFound = false;
            if (state.arMode) {
                els.statusText.innerText = "âš ï¸ å¯»æ‰¾æ ‡è®°...";
                els.statusDot.className = "status-dot";
                els.arImg.setAttribute('visible', 'false');
            }
        });

        // --- 6. æ‹–æ‹½é€»è¾‘ (ä¼˜åŒ–ç‚¹3ï¼šé¼ æ ‡æ”¯æŒ) ---
        let isDragging = false;
        let startX = 0, startY = 0;
        let initialScreenX = 0, initialScreenY = 0;

        const onDown = (clientX, clientY) => {
            if (state.locked || state.arMode) return;
            isDragging = true;
            startX = clientX;
            startY = clientY;
            initialScreenX = state.screenX;
            initialScreenY = state.screenY;
            els.screenLayer.style.cursor = 'grabbing';
        };

        const onMove = (clientX, clientY) => {
            if (!isDragging) return;
            const dx = clientX - startX;
            const dy = clientY - startY;
            state.screenX = initialScreenX + dx;
            state.screenY = initialScreenY + dy;
            updateVisuals();
        };

        const onUp = () => { isDragging = false; els.screenLayer.style.cursor = 'grab'; };

        els.screenLayer.addEventListener('mousedown', e => { e.preventDefault(); onDown(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => { if (isDragging) { e.preventDefault(); onMove(e.clientX, e.clientY); } });
        window.addEventListener('mouseup', onUp);
        
        els.screenLayer.addEventListener('touchstart', e => { if (e.touches.length===1) { e.preventDefault(); onDown(e.touches[0].clientX, e.touches[0].clientY); }}, {passive:false});
        window.addEventListener('touchmove', e => { if (isDragging && e.touches.length===1) { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); }}, {passive:false});
        window.addEventListener('touchend', onUp);

        function resetParams() {
            state.screenX = 0; state.screenY = 0;
            els.inputs.scale.value = 1; 
            els.inputs.rotate.value = 0;
            updateVisuals();
        }

        function toggleLock() {
            state.locked = !state.locked;
            document.getElementById('btn-lock').innerText = state.locked ? "ğŸ”’" : "ğŸ”“";
            els.controls.classList.toggle('locked', state.locked);
        }

        window.addEventListener('click', function () {
            const v = document.querySelector('video');
            if (v && v.paused) v.play();
        });

    </script>
</body>
</html>