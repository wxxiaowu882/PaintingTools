<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR ææ‘¹åŠ©æ‰‹ | è§†è§‰ç»´åº¦</title>
    
    <script async src="https://docs.opencv.org/4.5.5/opencv.js" onload="onOpenCvReady()"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #000; }
        
        #debug-console {
            position: fixed; top: 0; left: 0; width: 100%; height: 80px;
            background: rgba(0, 0, 0, 0.5); 
            color: #0f0; font-family: monospace; font-size: 9px;
            overflow-y: auto; z-index: 10000; padding: 5px; pointer-events: none;
            display: none; 
        }

        #global-viewport {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
        }

        #bg-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 1; 
            background: #000;
        }

        #screen-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: auto; overflow: hidden;
            display: none; cursor: grab;
            perspective: 1000px; 
            perspective-origin: 50% 100%;
        }
        #screen-layer:active { cursor: grabbing; }
        
        /* æ ¸å¿ƒæ¶æ„ä¿®æ”¹ï¼š
           æ–°å¢ä¸€ä¸ª transform-wrapper å®¹å™¨ã€‚
           æ‰€æœ‰çš„ 3D å˜æ¢ (rotate, scale, translate) éƒ½æ–½åŠ åœ¨è¿™ä¸ªå®¹å™¨ä¸Šã€‚
           å†…éƒ¨çš„ img å’Œ canvas åªè¦å¡«æ»¡å®¹å™¨å³å¯ï¼Œä¸å†å•ç‹¬åº”ç”¨å˜æ¢ã€‚
           è¿™èƒ½ç‰©ç†ä¸Šä¿è¯ 100% æ— åç§»ã€‚
        */
        #transform-wrapper {
            position: absolute;
            top: 38%; left: 50%;
            /* åˆå§‹å°ºå¯¸ä¸º0ï¼ŒåŠ è½½å›¾ç‰‡åç”± JS æ’‘å¼€ */
            width: 0; height: 0; 
            transform-origin: center bottom;
            transform: translate(-50%, -50%); /* åˆå§‹å±…ä¸­ */
            transform-style: preserve-3d;
            will-change: transform, opacity;
        }

        /* å†…éƒ¨å…ƒç´ ç»Ÿä¸€æ ·å¼ï¼Œç»å¯¹é‡åˆ */
        .layer-content {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: fill; /* ç¡®ä¿å¡«æ»¡å®¹å™¨ */
            pointer-events: none;
        }

        #screen-img {
            transition: opacity 0.2s ease; 
        }

        #cv-canvas {
            display: none; 
            /* ç®€å•çš„æ··åˆæ¨¡å¼å³å¯ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»ç”Ÿæˆäº†é€æ˜å›¾ */
        }

        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 85%; max-width: 320px; 
            background: rgba(10, 10, 12, 0.7); 
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 16px; 
            padding: 12px; 
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; 
            gap: 4px; 
            color: white; z-index: 100;
            transition: height 0.3s ease;
        }

        .btn-minimize {
            position: absolute; top: 6px; right: 6px;
            width: 24px; height: 24px; padding: 0;
            background: rgba(255,255,255,0.1); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; border: none; cursor: pointer; color: #ccc;
            z-index: 102; 
        }
        
        #restore-btn {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 44px; height: 44px; border-radius: 22px;
            background: rgba(20, 20, 22, 0.6); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            color: white; font-size: 20px; 
            display: none; 
            align-items: center; justify-content: center;
            z-index: 99; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .toolbar-row {
            display: flex; justify-content: flex-start; gap: 8px; margin-bottom: 4px; margin-right: 30px; 
        }

        .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; height: 32px; }
        
        .label { font-size: 11px; min-width: 42px; color: #ccc; text-align: right; line-height: 1; }
        
        input[type=range] { -webkit-appearance: none; flex: 1; background: transparent; height: 40px; margin: 0; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; border: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: #fff; box-shadow: 0 1px 5px rgba(0,0,0,0.5); margin-top: -10px; position: relative; z-index: 10; }

        .sketch-switch { width: 20px; height: 20px; accent-color: #007AFF; cursor: pointer; margin: 0; }

        button.panel-btn {
            flex: 1; padding: 6px 0; border-radius: 6px; border: none;
            background: rgba(255,255,255,0.1); color: white; font-size: 12px; font-weight: 500; 
            cursor: pointer; transition: 0.2s; max-width: 100px; 
        }
        button.active { background: #007AFF; color: white; }

        #more-controls { display: none; flex-direction: column; gap: 2px; }
        
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center;
        }
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="debug-console">æ—¥å¿—çª—å£...</div>

    <div id="start-screen">
        <h1 style="margin-bottom: 10px;">ğŸ¨ ææ‘¹åŠ©æ‰‹</h1>
        <p style="opacity: 0.6; margin-bottom: 40px; font-size: 14px;">OpenCV æ™ºèƒ½è‡ªé€‚åº”å¼•æ“</p>
        <div style="display: flex; flex-direction: column; gap: 15px; width: 200px;">
            <button onclick="document.getElementById('file-input').click()" style="background: #333; border: 1px solid #555; padding: 12px; border-radius: 8px; color:white;">
                1. é€‰æ‹©å›¾ç‰‡
            </button>
            <button id="btn-start-cam" onclick="startApp()" class="active" style="display: none; padding: 12px; border-radius: 8px; border:none; background:#007AFF; color:white;">
                2. å¯åŠ¨æ‘„åƒå¤´
            </button>
        </div>
        <input type="file" id="file-input" accept="image/*">
    </div>

    <div id="global-viewport">
        <video id="bg-video" autoplay playsinline muted></video>
        <div id="screen-layer">
            <!-- å˜æ¢å®¹å™¨ -->
            <div id="transform-wrapper">
                <img id="screen-img" class="layer-content" src="" alt="Original">
                <canvas id="cv-canvas" class="layer-content"></canvas>
            </div>
        </div>
    </div>

    <button id="restore-btn" onclick="toggleUI(true)">ğŸ› ï¸</button>

    <div class="ui-layer" id="controls" style="display: none;">
        <button class="btn-minimize" onclick="toggleUI(false)">ğŸ”½</button>

        <div class="toolbar-row">
             <button class="panel-btn" onclick="document.getElementById('file-input').click()" style="background: rgba(0,122,255,0.25); color: #4facfe;">ğŸ“‚ æ¢å›¾</button>
             <button class="panel-btn" id="btn-switch-cam" onclick="switchCamera()" style="display:none; background: rgba(255,255,255,0.15);">ğŸ”„ æ¢é•œ</button>
             <button class="panel-btn" id="btn-toggle-cam" onclick="toggleCameraState()" style="display:none; background: rgba(255,59,48,0.25); color: #ff6b6b; max-width: 40px;">â¹</button>
        </div>

        <div class="row">
            <span class="label">é€æ˜</span>
            <input type="range" id="opacity" min="0" max="1" step="0.001" value="0.5" oninput="updateVisuals()">
        </div>
        <div class="row">
            <span class="label">ç¼©æ”¾</span>
            <input type="range" id="scale" min="0.1" max="5.7" step="0.001" value="1" oninput="updateVisuals()">
        </div>

        <button class="panel-btn" id="btn-more" onclick="toggleMore()" style="background: rgba(255,255,255,0.05); color: #aaa; margin: 4px 0; font-size: 11px; padding: 4px 0; max-width: none;">ï¹€ æ›´å¤šè®¾ç½® (è§†è§’/çº¿ç¨¿)</button>

        <div id="more-controls">
            <div class="row">
                <span class="label">ä¿¯ä»°</span>
                <input type="range" id="rotateX" min="-60" max="60" step="1" value="0" oninput="updateVisuals()">
            </div>
            <div class="row">
                <span class="label">è§†è·</span>
                <input type="range" id="perspective" min="200" max="1800" step="10" value="1000" oninput="updateVisuals()">
            </div>

            <div class="row">
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span class="label" style="text-align: left; min-width: auto; color:#fff;">çº¿ç¨¿</span>
                    <input type="checkbox" id="sketch-toggle" class="sketch-switch" onchange="toggleSketchMode()">
                </div>
                
                <div style="display: flex; align-items: center; gap: 6px; flex: 1; margin-left: 10px;">
                    <span class="label" style="min-width: auto;">ç»†èŠ‚</span>
                    <!-- è‡ªé€‚åº”é˜ˆå€¼ Block Size: å¿…é¡»æ˜¯å¥‡æ•°ï¼ŒèŒƒå›´ 3-99 -->
                    <!-- æ»‘å—é€»è¾‘ï¼šå€¼è¶Šå°ï¼ŒBlockè¶Šå°ï¼Œå¯¹å±€éƒ¨ç»†èŠ‚è¶Šæ•æ„Ÿ -->
                    <input type="range" id="lineStrength" min="0" max="100" step="1" value="50" oninput="updateCvThreshold()" disabled>
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 8px; margin-top: 6px;">
            <button class="panel-btn" onclick="toggleLock()" id="btn-lock" style="max-width: none;">ğŸ”“ é”å®šç”»é¢</button>
            <button class="panel-btn" onclick="resetParams()" style="max-width: none;">é‡ç½®</button>
        </div>
    </div>

    <script>
        let cvReady = false;
        function onOpenCvReady() { cvReady = true; console.log("OpenCV Ready"); }
        function log(msg) { console.log(msg); } // ç®€åŒ–æ—¥å¿—

        const state = {
            imageLoaded: false,
            locked: false,
            videoTrack: null,   
            videoDevices: [], 
            currentDeviceIndex: 0,
            cameraActive: false,
            sketchMode: false,
            opacity: 0.5,
            scale: 1, 
            lineStrength: 50, // æ˜ å°„åˆ° BlockSize
            perspective: 1000, 
            rotateX: 0,
            screenX: 0,
            screenY: 0
        };

        const els = {
            startScreen: document.getElementById('start-screen'),
            fileInput: document.getElementById('file-input'),
            btnStartCam: document.getElementById('btn-start-cam'),
            screenLayer: document.getElementById('screen-layer'), 
            wrapper: document.getElementById('transform-wrapper'), // æ–°å¢å®¹å™¨
            screenImg: document.getElementById('screen-img'),
            cvCanvas: document.getElementById('cv-canvas'),
            controls: document.getElementById('controls'),
            restoreBtn: document.getElementById('restore-btn'),
            bgVideo: document.getElementById('bg-video'),
            btnLock: document.getElementById('btn-lock'),
            btnSwitch: document.getElementById('btn-switch-cam'),
            btnToggleCam: document.getElementById('btn-toggle-cam'),
            sketchToggle: document.getElementById('sketch-toggle'),
            inputs: {
                opacity: document.getElementById('opacity'),
                scale: document.getElementById('scale'),
                lineStrength: document.getElementById('lineStrength'),
                perspective: document.getElementById('perspective'),
                rotateX: document.getElementById('rotateX')
            }
        };

        function toggleUI(show) {
            els.controls.style.display = show ? 'flex' : 'none';
            els.restoreBtn.style.display = show ? 'none' : 'flex';
        }

        function toggleMore() {
            const moreDiv = document.getElementById('more-controls');
            const btn = document.getElementById('btn-more');
            if (moreDiv.style.display === 'none' || moreDiv.style.display === '') {
                moreDiv.style.display = 'flex';
                btn.innerText = "ï¸¿ æ”¶èµ·è®¾ç½®";
            } else {
                moreDiv.style.display = 'none';
                btn.innerText = "ï¹€ æ›´å¤šè®¾ç½® (è§†è§’/çº¿ç¨¿)";
            }
        }

        // === OpenCV è‡ªé€‚åº”é˜ˆå€¼é€»è¾‘ (æ™ºèƒ½ç‰ˆ) ===
        let processingTimer = null;

        function toggleSketchMode() {
            if (!cvReady) {
                alert("OpenCV å¼•æ“åŠ è½½ä¸­...");
                els.sketchToggle.checked = false;
                return;
            }

            state.sketchMode = els.sketchToggle.checked;
            els.inputs.lineStrength.disabled = !state.sketchMode;
            els.inputs.lineStrength.style.opacity = state.sketchMode ? "1" : "0.3";

            if (state.sketchMode) {
                els.cvCanvas.style.display = 'block';
                els.screenImg.style.opacity = 0; 
                processOpenCV(); 
            } else {
                els.cvCanvas.style.display = 'none';
                els.screenImg.style.opacity = state.opacity;
            }
            updateVisuals();
        }

        function updateCvThreshold() {
            if (!state.sketchMode) return;
            state.lineStrength = parseInt(els.inputs.lineStrength.value);
            if (processingTimer) clearTimeout(processingTimer);
            processingTimer = setTimeout(processOpenCV, 100);
        }

        function processOpenCV() {
            if (!cvReady || !els.screenImg.src) return;

            try {
                let src = cv.imread(els.screenImg);
                let gray = new cv.Mat();
                let edges = new cv.Mat();
                let dst = new cv.Mat();
                
                // 1. è½¬ç°åº¦
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                
                // 2. é«˜æ–¯æ¨¡ç³Š (è½»å¾®å»å™ª)
                let ksize = new cv.Size(3, 3);
                cv.GaussianBlur(gray, gray, ksize, 0, 0, cv.BORDER_DEFAULT);

                // 3. è‡ªé€‚åº”é˜ˆå€¼ (Adaptive Threshold) - æ™ºèƒ½æå–è‡ªç„¶çº¿æ¡
                // Block Size å†³å®šå±€éƒ¨æ•æ„Ÿåº¦ã€‚å¿…é¡»æ˜¯å¥‡æ•°ã€‚
                // æ˜ å°„è§„åˆ™ï¼šæ»‘å— 0-100 -> BlockSize 3-31 (çº¦)
                // å€¼è¶Šå°ï¼Œç»†èŠ‚è¶Šå¤šï¼›å€¼è¶Šå¤§ï¼Œåªçœ‹å¤§è½®å»“ã€‚
                let blockSize = 3 + 2 * Math.floor((100 - state.lineStrength) / 7); 
                if (blockSize < 3) blockSize = 3;
                
                // C (Constant) å‡å»çš„å¸¸æ•°ï¼Œç”¨äºå»å™ªèƒŒæ™¯
                let C = 2; 

                // ADAPTIVE_THRESH_GAUSSIAN_C æ¯” MEAN_C æ›´è‡ªç„¶
                cv.adaptiveThreshold(gray, edges, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, C);

                // 4. åè‰² (å› ä¸º adaptiveThreshold è¾“å‡ºæ˜¯ ç™½çº¸é»‘å­—ï¼Œæˆ‘ä»¬éœ€è¦ é»‘çº¸ç™½çº¿ ä½œä¸º Alpha)
                // å®é™…ä¸Š adaptiveThreshold ç»“æœï¼šèƒŒæ™¯ç™½(255)ï¼Œçº¿æ¡é»‘(0)
                // æˆ‘ä»¬æƒ³è¦ï¼šèƒŒæ™¯é€æ˜(Alpha 0)ï¼Œçº¿æ¡é»‘(Alpha 255)
                // æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠ 0->255 (çº¿æ¡), 255->0 (èƒŒæ™¯)
                cv.bitwise_not(edges, edges); 

                // 5. æ„å»ºé€æ˜å›¾ (RGBA)
                // RGB = 0 (é»‘)
                // A = edges
                let channels = new cv.MatVector();
                let black = new cv.Mat.zeros(edges.rows, edges.cols, cv.CV_8UC1);
                
                channels.push_back(black); // R
                channels.push_back(black); // G
                channels.push_back(black); // B
                channels.push_back(edges); // A
                
                cv.merge(channels, dst);

                cv.imshow('cv-canvas', dst);

                src.delete(); gray.delete(); edges.delete(); dst.delete(); 
                black.delete(); channels.delete(); ksize = null;

            } catch (err) {
                console.error(err);
            }
        }

        // === å›¾ç‰‡åŠ è½½ä¸å®¹å™¨å°ºå¯¸åŒæ­¥ ===
        els.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const imgUrl = URL.createObjectURL(file);
            els.screenImg.src = imgUrl;
            
            els.screenImg.onload = () => {
                state.imageLoaded = true;
                els.btnStartCam.style.display = 'block'; 
                
                // å…³é”®ï¼šæ ¹æ®å›¾ç‰‡åŸå§‹å°ºå¯¸è®¾ç½® wrapper å°ºå¯¸
                // è¿™æ · transform-origin æ‰èƒ½æ­£ç¡®å·¥ä½œ
                const w = els.screenImg.naturalWidth;
                const h = els.screenImg.naturalHeight;
                
                // ä¿æŒæ¯”ä¾‹ç¼©æ”¾åˆ°å±å¹•åˆé€‚å¤§å°
                // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ç›´æ¥è®¾ä¸º naturalSizeï¼Œç„¶åé  scale ç¼©æ”¾
                // ä¸ºäº†é¿å…è¿‡å¤§å¯¼è‡´å†…å­˜çˆ†ï¼Œé™åˆ¶ä¸€ä¸‹
                els.wrapper.style.width = w + "px";
                els.wrapper.style.height = h + "px";
                
                // åŒæ­¥ Canvas å¤§å°
                els.cvCanvas.width = w;
                els.cvCanvas.height = h;

                if (state.sketchMode) setTimeout(processOpenCV, 100);
                updateVisuals();
            };
        });

        async function startApp() {
            if (!state.imageLoaded) return;
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                state.videoDevices = devices.filter(d => d.kind === 'videoinput');
                if (state.videoDevices.length > 1) els.btnSwitch.style.display = 'block';

                let constraints = { audio: false, video: { facingMode: 'environment', width: { ideal: 3840 } } };
                
                const wideDevice = state.videoDevices.find(d => {
                    const l = d.label.toLowerCase();
                    return (l.includes('back') || l.includes('rear')) && (l.includes('wide') || l.includes('0.5'));
                });

                if (wideDevice) {
                    constraints.video = { deviceId: { exact: wideDevice.deviceId }, width: { ideal: 3840 } };
                    state.currentDeviceIndex = state.videoDevices.indexOf(wideDevice);
                }

                await initStream(constraints);
            } catch (err) {
                alert("æ‘„åƒå¤´é”™è¯¯: " + err.message);
            }
            els.startScreen.style.display = 'none';
            els.screenLayer.style.display = 'block'; 
            els.controls.style.display = 'flex';
            updateVisuals();
        }

        async function initStream(constraints) {
            if (state.videoTrack) state.videoTrack.stop();
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            els.bgVideo.srcObject = stream;
            state.videoTrack = stream.getVideoTracks()[0];
            state.cameraActive = true;
            els.btnToggleCam.style.display = 'block'; 
            els.btnToggleCam.innerText = 'â¹';
        }

        async function switchCamera() {
            if (state.videoDevices.length < 2) return;
            state.currentDeviceIndex = (state.currentDeviceIndex + 1) % state.videoDevices.length;
            const device = state.videoDevices[state.currentDeviceIndex];
            const constraints = { audio: false, video: { deviceId: { exact: device.deviceId }, width: { ideal: 3840 } } };
            await initStream(constraints);
        }

        function toggleCameraState() {
            if (!state.videoTrack) return;
            if (state.cameraActive) {
                state.videoTrack.stop(); 
                els.bgVideo.srcObject = null;
                state.cameraActive = false;
                els.btnToggleCam.innerText = 'â–¶';
                els.btnToggleCam.style.background = 'rgba(76, 217, 100, 0.25)';
            } else {
                const device = state.videoDevices[state.currentDeviceIndex];
                const constraints = { audio: false, video: device ? { deviceId: { exact: device.deviceId } } : { facingMode: 'environment' } };
                initStream(constraints).then(() => {
                    els.btnToggleCam.innerText = 'â¹';
                    els.btnToggleCam.style.background = 'rgba(255, 59, 48, 0.25)';
                });
            }
        }

        function updateVisuals() {
            state.opacity = els.inputs.opacity.value;
            state.scale = els.inputs.scale.value;
            state.perspective = els.inputs.perspective.value;
            state.rotateX = els.inputs.rotateX.value;

            els.screenLayer.style.perspective = `${state.perspective}px`;
            
            if (state.sketchMode) {
                els.cvCanvas.style.opacity = state.opacity;
            } else {
                els.screenImg.style.opacity = state.opacity;
            }

            // æ‰€æœ‰çš„å˜æ¢éƒ½åº”ç”¨åœ¨ wrapper ä¸Š
            // å†…éƒ¨ img å’Œ canvas ä¸éœ€è¦ transform
            const transform = `
                translate(calc(-50% + ${state.screenX}px), calc(-50% + ${state.screenY}px)) 
                rotateX(${state.rotateX}deg) 
                scale(${state.scale})
            `;
            els.wrapper.style.transform = transform;
        }

        let isDragging = false;
        let startX = 0, startY = 0;
        let initialScreenX = 0, initialScreenY = 0;

        const onDown = (clientX, clientY) => {
            if (state.locked) return;
            isDragging = true;
            startX = clientX;
            startY = clientY;
            initialScreenX = state.screenX;
            initialScreenY = state.screenY;
            els.screenLayer.style.cursor = 'grabbing';
        };

        const onMove = (clientX, clientY) => {
            if (!isDragging) return;
            const dx = clientX - startX;
            const dy = clientY - startY;
            state.screenX = initialScreenX + dx;
            state.screenY = initialScreenY + dy;
            updateVisuals();
        };

        const onUp = () => { isDragging = false; els.screenLayer.style.cursor = 'grab'; };

        els.screenLayer.addEventListener('touchstart', e => {
            if (e.touches.length === 1) onDown(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive:false});

        window.addEventListener('touchmove', e => {
            if (e.touches.length === 1 && isDragging) {
                e.preventDefault();
                onMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive:false});

        window.addEventListener('touchend', e => { if (e.touches.length === 0) onUp(); });
        els.screenLayer.addEventListener('mousedown', e => { e.preventDefault(); onDown(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => { if (isDragging) { e.preventDefault(); onMove(e.clientX, e.clientY); } });
        window.addEventListener('mouseup', onUp);

        function resetParams() {
            state.screenX = 0; state.screenY = 0;
            els.inputs.scale.value = 1; 
            els.inputs.perspective.value = 1000; 
            els.inputs.rotateX.value = 0;
            els.wrapper.style.transform = `translate(-50%, -50%) scale(1)`;
            updateVisuals();
        }

        function toggleLock() {
            state.locked = !state.locked;
            els.btnLock.innerText = state.locked ? "ğŸ”’ å·²é”å®š" : "ğŸ”“ é”å®šç”»é¢";
            els.btnLock.style.background = state.locked ? "#FF3B30" : "rgba(255,255,255,0.15)";
            els.inputs.scale.disabled = state.locked;
            els.inputs.perspective.disabled = state.locked;
            els.inputs.rotateX.disabled = state.locked;
        }

        document.body.addEventListener('click', () => { if(els.bgVideo.paused) els.bgVideo.play(); }, {once:true});
    </script>
</body>
</html>