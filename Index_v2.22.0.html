<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ç«¥ç”»å¸ˆå´æ™“çš„ç»˜ç”»å·¥ä½œå° v2.18</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #e67e22;
            --bg-color: #ffffff;
            --card-bg: #ffffff;
            --text-color: #2c3e50;
            --paper-ratio: 0.716; /* ç«–å‘æ¯”ä¾‹ï¼š265mm / 370mm */
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            text-align: center; 
            padding: 0; 
            background-color: var(--bg-color); 
            color: var(--text-color); 
            margin: 0; 
            overflow-x: hidden;
        }
        
        .container { 
            max-width: 100%; margin: 0 auto; background: var(--card-bg); padding: 0; box-shadow: none;
        }
        
        header { padding: 10px 15px 0 15px; }
        h1 { margin: 0 0 5px 0; color: #333; letter-spacing: -0.5px; font-size: 1.2rem; }
        
        .tabs { display: flex; justify-content: center; margin-bottom: 10px; border-bottom: 1px solid #eee; padding: 0 10px; }
        .tab-btn { flex: 1; max-width: 150px; padding: 12px 0; border: none; background: none; font-size: 16px; font-weight: 600; color: #888; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab-btn.active { color: var(--primary-color); border-bottom-color: var(--primary-color); color: #333; }
        .tab-content { display: none; animation: fadeIn 0.4s ease; padding-bottom: 40px; }
        .tab-content.active { display: block; }

        .controls { background: #f9f9f9; padding: 10px 15px; border-bottom: 1px solid #eee; display: flex; flex-direction: column; gap: 10px; }
        .control-row { display: flex; flex-wrap: wrap; gap: 8px; justify-content: space-between; align-items: center; width: 100%; }
        .control-group { display: flex; flex-direction: column; align-items: flex-start; gap: 5px; }
        .control-group.full-width { width: 100%; max-width: 100%; }
        
        .btn { padding: 8px 0; width: 100%; background-color: var(--primary-color); color: #ffffff !important; border: none; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 600; display: inline-flex; align-items: center; justify-content: center; gap: 5px; white-space: nowrap; height: 40px; }
        .btn:active { opacity: 0.8; }
        .btn-orange { background-color: var(--secondary-color); }
        .btn-outline { background-color: #fff; border: 1px solid #ddd; color: #555 !important; box-shadow: none; }
        .btn-outline-orange { border-color: var(--secondary-color); color: var(--secondary-color) !important; }
        
        .btn-sm { padding: 0 12px; height: 32px; font-size: 13px; border-radius: 4px; width: auto; background: #eee; color: #333 !important; }
        .btn-micro { width: 36px; height: 36px; padding: 0; border-radius: 50%; background: #fff; border: 1px solid #ddd; color: #555; font-size: 20px; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; }

        input[type="file"] { display: none; }
        
        .color-picker-wrapper { width: 36px; height: 36px; border-radius: 50%; overflow: hidden; border: 2px solid #fff; box-shadow: 0 0 0 1px #ddd; position: relative; flex-shrink: 0; }
        input[type="color"] { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; padding: 0; margin: 0; border: none; cursor: pointer; }

        .slider-container { display: flex; align-items: center; gap: 8px; flex: 1; background: #fff; padding: 0 10px; border-radius: 20px; border: 1px solid #eee; height: 36px; }
        input[type="range"] { flex: 1; accent-color: var(--primary-color); cursor: pointer; height: 100%; width: 100%; margin: 0; }

        /* ç”»å¸ƒè§†çª—å®¹å™¨ */
        .canvas-window { 
            position: relative; 
            width: 100vw; 
            height: calc(100vw / var(--paper-ratio)); 
            max-height: 75vh; 
            background: #eef2f5; 
            overflow: hidden; 
            display: flex; justify-content: center; align-items: center;
            user-select: none; cursor: default;
            margin: 0 auto;
            border-top: 1px solid #eee; border-bottom: 1px solid #eee;
        }
        
        .canvas-window.has-image { background: #333; }
        
        canvas { 
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
            background: #fff; 
            transform-origin: center center; 
        }

        .bottom-toolbar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: #fff; border-top: 1px solid #eee; width: 100%;
        }
        .zoom-controls { display: flex; align-items: center; gap: 10px; flex: 1; justify-content: center; }
        .zoom-display { font-size: 12px; color: #999; width: 40px; text-align: center; }

        .mode-switch {
            display: flex; gap: 0; border: 1px solid var(--primary-color); border-radius: 6px; overflow: hidden; width: 100%;
        }
        .mode-btn {
            padding: 8px; border: none; background: #fff; color: var(--primary-color); cursor: pointer; font-size: 13px; font-weight: 600; flex: 1; margin: 0; height: auto; border-radius: 0;
        }
        .mode-btn.active { background: var(--primary-color); color: #fff; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>ç«¥ç”»å¸ˆå´æ™“çš„ç»˜ç”»å·¥ä½œå°</h1>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('grid')">ğŸ“ ç½‘æ ¼èµ·å‹</button>
            <button class="tab-btn" onclick="switchTab('poster')">ğŸ¨ è‰²é˜¶æ¦‚æ‹¬</button>
        </div>
    </header>

    <!-- åŠŸèƒ½åŒº1ï¼šç½‘æ ¼å·¥å…· -->
    <div id="grid-content" class="tab-content active">
        <div class="controls">
            <!-- 1. æ–‡ä»¶ä¸Šä¼  -->
            <div class="control-row">
                <label class="btn btn-upload">
                    ğŸ“‚ æ‰“å¼€ç›¸å†Œå›¾ç‰‡
                    <input type="file" id="gridImageInput" accept="image/*">
                </label>
            </div>

            <!-- 2. ç½‘æ ¼è°ƒæ•´ (Max 15, Default 3) -->
            <div class="control-row">
                 <div class="control-group full-width" style="flex-direction: row; align-items: center;">
                     <!-- å–è‰²æŒ‰é’®å·²ç»ç§»åˆ°ä¸‹é¢ä¸€è¡Œï¼Œè¿™é‡Œç§»é™¤ -->
                     <div class="slider-container">
                        <button class="btn-micro" onclick="adjustGridSize(-0.1)">-</button>
                        <input type="range" id="gridSize" min="2" max="15" value="3" step="0.05" oninput="drawGrid()">
                        <button class="btn-micro" onclick="adjustGridSize(0.1)">+</button>
                    </div>
                    <span id="gridSizeVal" style="font-size:12px; color:#999; width: 30px;">3.0</span>
                </div>
            </div>
            
            <!-- å–è‰²æŒ‰é’®å’Œæ–¹æ ¼å¤é€‰æ¡† -->
            <div class="control-row">
                <div class="control-group full-width" style="flex-direction: row; align-items: center; justify-content: center; gap: 15px;">
                    <!-- æ­£æ–¹å½¢å–è‰²æŒ‰é’® -->
                    <div class="color-picker-wrapper" title="ç½‘æ ¼é¢œè‰²" style="border-radius: 8px;">
                        <input type="color" id="gridColor" value="#ff0000" oninput="drawGrid()">
                    </div>
                    <!-- æ–¹æ ¼å¤é€‰æ¡† -->
                    <label style="display: flex; align-items: center; justify-content:center; padding:0 10px; background:#fff; border-radius:20px; height: 36px; border:1px solid #eee; flex-shrink: 0;">
                        <input type="checkbox" id="squareGridCheck" onchange="toggleSquareGrid()" style="width: 20px; height:20px; margin-right: 5px;"> 
                        <span style="font-size:12px; color:#555">æ–¹æ ¼</span>
                    </label>
                </div>
            </div>
            
            <!-- 3. æ¨¡å¼åˆ‡æ¢ -->
            <div class="control-row">
                <div class="mode-switch">
                    <button class="mode-btn active" id="modeMove" onclick="setGridMode('move')">âœ‹ åŒæŒ‡ç§»åŠ¨è§†å›¾</button>
                    <button class="mode-btn" id="modeGrid" onclick="setGridMode('grid')">ğŸ“ åŒæŒ‡è°ƒæ•´ç½‘æ ¼</button>
                </div>
            </div>
        </div>
        
        <!-- è§†çª— -->
        <div class="canvas-window" id="gridWindow">
            <div style="color:#999; font-size: 0.9rem;" id="gridPlaceholder">è¯·é€‰æ‹©å›¾ç‰‡<br>åŒæŒ‡æ“ä½œ</div>
            <canvas id="gridCanvas" style="display:none;"></canvas>
        </div>

        <!-- åº•éƒ¨å·¥å…· -->
        <div class="bottom-toolbar">
            <button class="btn-sm" onclick="resetGridOffset()">é‡ç½®ç½‘æ ¼</button>
            <div class="zoom-controls">
                <button class="btn-micro" onclick="updateZoom('grid', -0.1)">-</button>
                <span class="zoom-display" id="gridZoomVal">100%</span>
                <button class="btn-micro" onclick="updateZoom('grid', 0.1)">+</button>
            </div>
            <div style="display: flex; gap: 5px;">
                <button class="btn-sm" onclick="fitView('grid')">é€‚åº”</button>
            </div>
        </div>
        
        <div style="padding: 10px;">
            <button class="btn btn-outline" style="color:var(--primary-color)!important; background:#fff;" onclick="downloadCanvas('gridCanvas', 'ç½‘æ ¼å‚è€ƒå›¾.jpg')">â¬‡ï¸ ä¿å­˜ç»“æœå›¾</button>
        </div>
    </div>

    <!-- åŠŸèƒ½åŒº2ï¼šè‰²é˜¶å·¥å…· -->
    <div id="poster-content" class="tab-content">
        <div class="controls">
            <div class="control-row">
                <label class="btn btn-orange">
                    ğŸ“‚ æ‰“å¼€ç›¸å†Œå›¾ç‰‡
                    <input type="file" id="posterImageInput" accept="image/*">
                </label>
            </div>
            
            <div class="control-row">
                <div class="control-group full-width" style="flex-direction: row; align-items: center;">
                    <label style="display: flex; align-items: center; justify-content:center; padding:0 10px; background:#fff; border-radius:20px; height: 36px; border:1px solid #eee; flex-shrink: 0;">
                        <input type="checkbox" id="grayscaleCheck" onchange="processPoster()" style="width: 20px; height:20px; margin-right: 5px;"> 
                        <span style="font-size:12px; color:#555">é»‘ç™½</span>
                    </label>
                    
                    <div class="slider-container" style="border-color: #fce5cd;">
                        <button class="btn-micro" onclick="adjustPosterLevel(-1)">-</button>
                        <input type="range" id="posterLevel" min="2" max="20" value="12" step="1" oninput="processPoster()" style="accent-color: var(--secondary-color);">
                        <button class="btn-micro" onclick="adjustPosterLevel(1)">+</button>
                    </div>
                    <span id="posterLevelVal" style="font-size:12px; color:#e67e22; width: 20px;">12</span>
                </div>
            </div>
        </div>

        <div class="canvas-window" id="posterWindow">
            <div style="color:#999; font-size: 0.9rem;" id="posterPlaceholder">è¯·é€‰æ‹©å›¾ç‰‡</div>
            <canvas id="posterCanvas" style="display:none;"></canvas>
        </div>

        <div class="bottom-toolbar">
            <div style="width: 60px;"></div>
            <div class="zoom-controls">
                <button class="btn-micro" onclick="updateZoom('poster', -0.1)">-</button>
                <span class="zoom-display" id="posterZoomVal">100%</span>
                <button class="btn-micro" onclick="updateZoom('poster', 0.1)">+</button>
            </div>
            <div style="display: flex; gap: 5px;">
                <button class="btn-sm" onclick="fitView('poster')">é€‚åº”</button>
            </div>
        </div>

        <div style="padding: 10px;">
            <button class="btn btn-outline" style="color:var(--secondary-color)!important; border-color:var(--secondary-color); background:#fff;" onclick="downloadCanvas('posterCanvas', 'è‰²å—æ¦‚æ‹¬å›¾.jpg')">â¬‡ï¸ ä¿å­˜ç»“æœå›¾</button>
        </div>
    </div>

</div>

<script>
    // === çŠ¶æ€ç®¡ç† ===
    const state = {
        currentGridMode: 'move', // 'move' (default) or 'grid'
        grid: { scale: 1, panX: 0, panY: 0, isDraggingImg: false, isDraggingGrid: false, startX: 0, startY: 0, minScale: 1, lastDist: 0, lastCenter: {x:0, y:0}, density: 3.0, isSquareGrid: false },
        poster: { scale: 1, panX: 0, panY: 0, isDraggingImg: false, startX: 0, startY: 0, minScale: 1, lastDist: 0, lastCenter: {x:0, y:0} }
    };

    function setGridMode(mode) {
        state.currentGridMode = mode;
        document.getElementById('modeMove').className = mode === 'move' ? 'mode-btn active' : 'mode-btn';
        document.getElementById('modeGrid').className = mode === 'grid' ? 'mode-btn active' : 'mode-btn';
    }

    function switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        if(tabId === 'grid') {
            document.querySelector('.tabs button:nth-child(1)').classList.add('active');
            document.getElementById('grid-content').classList.add('active');
        } else {
            document.querySelector('.tabs button:nth-child(2)').classList.add('active');
            document.getElementById('poster-content').classList.add('active');
        }
    }

    // === æ ¸å¿ƒä¿®å¤ï¼šä¸‹è½½åŠŸèƒ½ (æ‰€è§å³æ‰€å¾—) ===
    function downloadCanvas(canvasId, filename) {
        const type = canvasId === 'gridCanvas' ? 'grid' : 'poster';
        // å…³é”®ä¿®å¤ï¼šä»å…¨å±€å˜é‡è·å–æºå›¾ç‰‡ï¼Œè€Œä¸æ˜¯state
        const sourceImg = type === 'grid' ? gridOriginalImg : posterOriginalImg;
        
        if (!sourceImg) { alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼'); return; }
        
        const stage = document.getElementById(type + 'Window');
        const sourceCanvas = document.getElementById(canvasId);
        const s = state[type];
        
        // åˆ¤æ–­å›¾ç‰‡æ˜¯å¦å®Œå…¨è¦†ç›–å¯è§†èŒƒå›´
        const scaledWidth = sourceCanvas.width * s.scale;
        const scaledHeight = sourceCanvas.height * s.scale;
        const imgLeft = (stage.clientWidth / 2) - (scaledWidth / 2) + s.panX;
        const imgTop = (stage.clientHeight / 2) - (scaledHeight / 2) + s.panY;
        
        const isFullyCovered = imgLeft <= 0 && imgTop <= 0 && 
                               imgLeft + scaledWidth >= stage.clientWidth && 
                               imgTop + scaledHeight >= stage.clientHeight;
        
        // åˆ›å»ºå¯¼å‡º Canvas
        const exportCanvas = document.createElement('canvas');
        
        if (isFullyCovered) {
            // å›¾ç‰‡å®Œå…¨è¦†ç›–å¯è§†èŒƒå›´ï¼šä¿å­˜æ‰€è§å³æ‰€å¾—ï¼ˆå½“å‰è§†çª—å†…å®¹ï¼‰
            exportCanvas.width = stage.clientWidth;
            exportCanvas.height = stage.clientHeight;
            const ctx = exportCanvas.getContext('2d');
            
            // å¡«å……ç™½è‰²èƒŒæ™¯
            ctx.fillStyle = '#ffffff'; 
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            ctx.save();
            
            // 1. ç§»åŠ¨åˆ°ä¸­å¿ƒ
            ctx.translate(exportCanvas.width / 2, exportCanvas.height / 2);
            
            // 2. åº”ç”¨å˜æ¢
            ctx.translate(s.panX, s.panY);
            ctx.scale(s.scale, s.scale);
            
            // 3. ç»˜åˆ¶æºå†…å®¹ (å›åˆ°å·¦ä¸Šè§’)
            ctx.translate(-sourceCanvas.width / 2, -sourceCanvas.height / 2);
            ctx.drawImage(sourceCanvas, 0, 0);
            
            ctx.restore();
        } else {
            // å›¾ç‰‡æœªå®Œå…¨è¦†ç›–å¯è§†èŒƒå›´ï¼šä¿å­˜å®é™…å›¾ç‰‡ï¼ˆä¸è£å‰ªï¼‰
            exportCanvas.width = sourceCanvas.width;
            exportCanvas.height = sourceCanvas.height;
            const ctx = exportCanvas.getContext('2d');
            
            // ç›´æ¥ç»˜åˆ¶æºç”»å¸ƒå†…å®¹ï¼ˆä¸åº”ç”¨å˜æ¢ï¼‰
            ctx.drawImage(sourceCanvas, 0, 0);
        }
        
        const link = document.createElement('a');
        link.download = filename;
        link.href = exportCanvas.toDataURL('image/jpeg', 0.95);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // === ç¼©æ”¾ä¸è§†å›¾æ§åˆ¶ç³»ç»Ÿ ===
    function calculateMinScale(type) {
        const win = document.getElementById(type + 'Window');
        const canvas = document.getElementById(type + 'Canvas');
        if(canvas.width === 0) return 1;
        return Math.min(win.clientWidth / canvas.width, win.clientHeight / canvas.height);
    }

    function updateCanvasTransform(type) {
        const s = state[type];
        const canvas = document.getElementById(type + 'Canvas');
        const zoomVal = document.getElementById(type + 'ZoomVal');
        canvas.style.transform = `translate3d(${s.panX}px, ${s.panY}px, 0) scale(${s.scale})`;
        zoomVal.innerText = Math.round(s.scale / s.minScale * 100) + '%';
    }

    function updateZoom(type, delta, isAbsolute = false) {
        const s = state[type];
        if (!s.minScale || s.minScale === 1) s.minScale = calculateMinScale(type);
        
        let newScale;
        if (isAbsolute) newScale = delta;
        else newScale = s.scale + (delta * s.minScale);

        if(newScale < s.minScale) newScale = s.minScale; 
        if(newScale > s.minScale * 10) newScale = s.minScale * 10;
        
        s.scale = newScale;
        if (Math.abs(s.scale - s.minScale) < 0.001) { s.panX = 0; s.panY = 0; }
        updateCanvasTransform(type);
    }

    function fitView(type) {
        const s = state[type];
        s.minScale = calculateMinScale(type);
        s.scale = s.minScale;
        s.panX = 0; s.panY = 0;
        updateCanvasTransform(type);
    }
    
    document.addEventListener('fullscreenchange', handleFsChange);
    document.addEventListener('webkitfullscreenchange', handleFsChange);
    function handleFsChange() {
        setTimeout(() => {
            if(state.grid.minScale) fitView('grid');
            if(state.poster.minScale) fitView('poster');
        }, 200);
    }

    // === æ ¸å¿ƒé€»è¾‘ ===
    const gridInput = document.getElementById('gridImageInput');
    const gridCanvas = document.getElementById('gridCanvas');
    const gridCtx = gridCanvas.getContext('2d');
    let gridOriginalImg = null; let gridOffsetX = 0; let gridOffsetY = 0;

    gridInput.addEventListener('change', (e) => handleImageUpload(e, 'grid'));

    function handleImageUpload(e, type) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                if(type === 'grid') {
                    gridOriginalImg = img;
                    document.getElementById('gridPlaceholder').style.display = 'none';
                    gridCanvas.style.display = 'block';
                    document.getElementById('gridWindow').classList.add('has-image');
                    gridOffsetX = 0; gridOffsetY = 0;
                    drawGrid(); setTimeout(() => fitView('grid'), 50); 
                } else {
                    posterOriginalImg = img;
                    document.getElementById('posterPlaceholder').style.display = 'none';
                    posterCanvas.style.display = 'block';
                    document.getElementById('posterWindow').classList.add('has-image');
                    processPoster(); setTimeout(() => fitView('poster'), 50);
                }
            }
            img.src = event.target.result;
        }
        reader.readAsDataURL(file);
    }

    function adjustGridSize(delta) {
        const slider = document.getElementById('gridSize');
        let newVal = parseFloat(slider.value) + delta;
        if(newVal < 2) newVal = 2; if(newVal > 15) newVal = 15;
        slider.value = newVal; drawGrid();
    }

    function resetGridOffset() { 
        gridOffsetX = 0; gridOffsetY = 0; 
        document.getElementById('gridSize').value = 3;
        drawGrid(); 
    }

    function drawGrid() {
        if (!gridOriginalImg) return;
        const size = parseFloat(document.getElementById('gridSize').value);
        const color = document.getElementById('gridColor').value;
        document.getElementById('gridSizeVal').textContent = size.toFixed(1);
        gridCanvas.width = gridOriginalImg.width;
        gridCanvas.height = gridOriginalImg.height;
        gridCtx.drawImage(gridOriginalImg, 0, 0);
        gridCtx.strokeStyle = color;
        gridCtx.lineWidth = Math.max(1.5, gridOriginalImg.width / 800);
        gridCtx.beginPath();
        
        if (state.grid.isSquareGrid) {
            // æ­£æ–¹å½¢ç½‘æ ¼æ¨¡å¼
            const shortSide = Math.min(gridCanvas.width, gridCanvas.height);
            const squareSize = shortSide / size; // æ­£æ–¹å½¢è¾¹é•¿
            // ç¡®å®šçŸ­è¾¹æ˜¯å®½åº¦è¿˜æ˜¯é«˜åº¦
            const isWidthShort = gridCanvas.width <= gridCanvas.height;
            
            if (isWidthShort) {
                // å®½åº¦æ˜¯çŸ­è¾¹ï¼Œä¿æŒæ¨ªå‘çº¿æ¡æ•°é‡ä¸å˜ï¼Œè°ƒæ•´çºµå‘çº¿æ¡
                const stepX = gridCanvas.width / size;
                const stepY = squareSize; // çºµå‘æ­¥é•¿ä¸ºæ­£æ–¹å½¢è¾¹é•¿
                // æ¨ªå‘çº¿æ¡ï¼ˆçŸ­è¾¹æ–¹å‘ï¼‰
                let startX = gridOffsetX % stepX; if (startX > 0) startX -= stepX;
                for (let x = startX; x < gridCanvas.width; x += stepX) {
                    gridCtx.moveTo(x, 0);
                    gridCtx.lineTo(x, gridCanvas.height);
                }
                // çºµå‘çº¿æ¡ï¼ˆé•¿è¾¹æ–¹å‘ï¼‰
                let startY = gridOffsetY % stepY; if (startY > 0) startY -= stepY;
                for (let y = startY; y < gridCanvas.height; y += stepY) {
                    gridCtx.moveTo(0, y);
                    gridCtx.lineTo(gridCanvas.width, y);
                }
            } else {
                // é«˜åº¦æ˜¯çŸ­è¾¹ï¼Œä¿æŒçºµå‘çº¿æ¡æ•°é‡ä¸å˜ï¼Œè°ƒæ•´æ¨ªå‘çº¿æ¡
                const stepX = squareSize; // æ¨ªå‘æ­¥é•¿ä¸ºæ­£æ–¹å½¢è¾¹é•¿
                const stepY = gridCanvas.height / size;
                // æ¨ªå‘çº¿æ¡ï¼ˆé•¿è¾¹æ–¹å‘ï¼‰
                let startX = gridOffsetX % stepX; if (startX > 0) startX -= stepX;
                for (let x = startX; x < gridCanvas.width; x += stepX) {
                    gridCtx.moveTo(x, 0);
                    gridCtx.lineTo(x, gridCanvas.height);
                }
                // çºµå‘çº¿æ¡ï¼ˆçŸ­è¾¹æ–¹å‘ï¼‰
                let startY = gridOffsetY % stepY; if (startY > 0) startY -= stepY;
                for (let y = startY; y < gridCanvas.height; y += stepY) {
                    gridCtx.moveTo(0, y);
                    gridCtx.lineTo(gridCanvas.width, y);
                }
            }
        } else {
            // é•¿æ–¹å½¢ç½‘æ ¼æ¨¡å¼ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
            const stepX = gridCanvas.width / size;
            const stepY = gridCanvas.height / size;
            let startX = gridOffsetX % stepX; if (startX > 0) startX -= stepX;
            for (let x = startX; x < gridCanvas.width; x += stepX) { gridCtx.moveTo(x, 0); gridCtx.lineTo(x, gridCanvas.height); }
            let startY = gridOffsetY % stepY; if (startY > 0) startY -= stepY;
            for (let y = startY; y < gridCanvas.height; y += stepY) { gridCtx.moveTo(0, y); gridCtx.lineTo(gridCanvas.width, y); }
        }
        gridCtx.stroke();
    }

    function toggleSquareGrid() {
        // åˆ‡æ¢æ­£æ–¹å½¢ç½‘æ ¼çŠ¶æ€
        const checkbox = document.getElementById('squareGridCheck');
        state.grid.isSquareGrid = checkbox.checked;
        // é‡æ–°ç»˜åˆ¶ç½‘æ ¼
        drawGrid();
    }

    // === æ‰‹åŠ¿æ§åˆ¶æ ¸å¿ƒ ===
    
    function getCenter(touches) {
        return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2
        };
    }
    
    function getDistance(touches) {
        return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
    }

    function handleStart(e, type) {
        if (!e.touches) {
            if (type === 'grid' && !gridOriginalImg) return;
            if (type === 'poster' && !posterOriginalImg) return;
            state[type].startX = e.clientX;
            state[type].startY = e.clientY;
            state[type].isDraggingImg = (type === 'poster' || state.currentGridMode === 'move');
            state[type].isDraggingGrid = (type === 'grid' && state.currentGridMode === 'grid');
            return;
        }

        if (e.touches.length === 2) {
            if (type === 'grid' && !gridOriginalImg) return;
            if (type === 'poster' && !posterOriginalImg) return;
            
            const s = state[type];
            s.lastDist = getDistance(e.touches);
            s.lastCenter = getCenter(e.touches);
            
            s.isDraggingImg = (type === 'poster' || state.currentGridMode === 'move');
            s.isDraggingGrid = (type === 'grid' && state.currentGridMode === 'grid');
        }
    }

    function handleMove(e, type) {
        if (!e.touches) {
            const s = state[type];
            if (s.isDraggingGrid) {
                updateGridOffset(e.clientX - s.startX, e.clientY - s.startY);
                s.startX = e.clientX; s.startY = e.clientY;
            } else if (s.isDraggingImg) {
                updateImgPan(type, e.clientX - s.startX, e.clientY - s.startY);
                s.startX = e.clientX; s.startY = e.clientY;
            }
            return;
        }

        if (e.touches.length === 2) {
            e.preventDefault(); 
            const s = state[type];
            
            // 1. å¦‚æœæ˜¯ç½‘æ ¼æ¨¡å¼ï¼Œåªç§»åŠ¨ç½‘æ ¼ (ä¿®æ­£: ç¦æ­¢ç¼©æ”¾)
            if (s.isDraggingGrid) {
                const currentCenter = getCenter(e.touches);
                const deltaX = currentCenter.x - s.lastCenter.x;
                const deltaY = currentCenter.y - s.lastCenter.y;
                updateGridOffset(deltaX, deltaY);
                s.lastCenter = currentCenter;
                return; // å…³é”®ï¼šç›´æ¥è¿”å›ï¼Œä¸æ‰§è¡Œç¼©æ”¾
            }

            // 2. æ­£å¸¸ç§»åŠ¨è§†å›¾æ¨¡å¼ (ç¼©æ”¾+ç§»åŠ¨)
            const currentDist = getDistance(e.touches);
            const scaleRatio = currentDist / s.lastDist;
            const newScale = s.scale * scaleRatio;
            updateZoom(type, newScale, true);
            s.lastDist = currentDist;

            const currentCenter = getCenter(e.touches);
            const deltaX = currentCenter.x - s.lastCenter.x;
            const deltaY = currentCenter.y - s.lastCenter.y;
            
            if (s.isDraggingImg) {
                updateImgPan(type, deltaX, deltaY);
            }
            s.lastCenter = currentCenter;
        }
    }

    function updateGridOffset(dx, dy) {
        const rect = gridCanvas.getBoundingClientRect();
        const scaleX = gridCanvas.width / rect.width;
        const scaleY = gridCanvas.height / rect.height;
        gridOffsetX += dx * scaleX;
        gridOffsetY += dy * scaleY;
        drawGrid();
    }

    function updateImgPan(type, dx, dy) {
        const s = state[type];
        s.panX += dx;
        s.panY += dy;
        updateCanvasTransform(type);
    }

    function handleEnd(e) {
        state.grid.isDraggingImg = false;
        state.grid.isDraggingGrid = false;
        state.poster.isDraggingImg = false;
    }

    // ç»‘å®šäº‹ä»¶
    const gridWin = document.getElementById('gridWindow');
    const posterWin = document.getElementById('posterWindow');

    gridWin.addEventListener('mousedown', (e) => handleStart(e, 'grid'));
    gridWin.addEventListener('mousemove', (e) => handleMove(e, 'grid'));
    gridWin.addEventListener('touchstart', (e) => handleStart(e, 'grid'), {passive: false});
    gridWin.addEventListener('touchmove', (e) => handleMove(e, 'grid'), {passive: false});

    posterWin.addEventListener('mousedown', (e) => handleStart(e, 'poster'));
    posterWin.addEventListener('mousemove', (e) => handleMove(e, 'poster'));
    posterWin.addEventListener('touchstart', (e) => handleStart(e, 'poster'), {passive: false});
    posterWin.addEventListener('touchmove', (e) => handleMove(e, 'poster'), {passive: false});

    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('touchend', handleEnd);


    // === è‰²é˜¶å·¥å…·é€»è¾‘ ===
    const posterInput = document.getElementById('posterImageInput');
    const posterCanvas = document.getElementById('posterCanvas');
    const posterCtx = posterCanvas.getContext('2d');
    let posterOriginalImg = null;

    posterInput.addEventListener('change', (e) => handleImageUpload(e, 'poster'));

    function adjustPosterLevel(delta) {
        const slider = document.getElementById('posterLevel');
        let val = parseInt(slider.value) + delta;
        if(val < 2) val = 2; if(val > 20) val = 20;
        slider.value = val; processPoster();
    }

    function processPoster() {
        if (!posterOriginalImg) return;
        const levels = parseInt(document.getElementById('posterLevel').value);
        const isGray = document.getElementById('grayscaleCheck').checked;
        document.getElementById('posterLevelVal').textContent = levels;
        posterCanvas.width = posterOriginalImg.width;
        posterCanvas.height = posterOriginalImg.height;
        posterCtx.drawImage(posterOriginalImg, 0, 0);
        const imageData = posterCtx.getImageData(0, 0, posterCanvas.width, posterCanvas.height);
        const data = imageData.data;
        const step = 255 / (levels - 1);
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i+1], b = data[i+2];
            if (isGray) {
                const avg = 0.299*r + 0.587*g + 0.114*b;
                r=g=b=avg;
            }
            r = Math.floor(r / step) * step;
            g = Math.floor(g / step) * step;
            b = Math.floor(b / step) * step;
            data[i] = r; data[i+1] = g; data[i+2] = b;
        }
        posterCtx.putImageData(imageData, 0, 0);
    }
</script>

</body>
</html>
